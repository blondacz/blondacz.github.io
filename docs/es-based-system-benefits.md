# Actor-Based Event-Sourcing System with CQRS, Transactionality, and High Availability

This document describes an **actor-based event-sourcing system** that utilizes **CQRS** concepts, ensures **exactly-once** processing, and provides **high availability** through replication. 
Each domain entity is modeled as an actor, which processes commands, generates events.

---

## 1. Command Handling and Transactionality

1. **Actor Model and Domain Entities**  
   Each entity (e.g., Obligation, Instruction, WorkItem) is represented by its own actor. A command such as `Settle` or `Confirm` is routed to the appropriate actor or set of actors.

2. **Depth-First Traversal**  
   A single command can result in updates to one or many actors. Each actor may generate zero or more events to update its own state, and can also send further commands to other actors within the same transaction flow. This traversal happens in a depth-first manner until all required updates are completed.

3. **All-or-Nothing Event Persistence**  
   Once the entire command flow and actor traversal finish successfully, all generated events are persisted together. If any part fails, no events are persisted. This ensures a strict transactional boundary: either all changes from a command succeed, or none do.

---

## 2. Event-Sourcing with Exactly-Once Guarantees

1. **Event Generation**  
   Actors record every state change in the form of domain events (e.g., `OrderPlaced`, `InventoryDecremented`). These events provide an immutable, auditable history of all state transitions.

2. **Immutability and Recovery**  
   Because events are immutable and stored in sequence, an actor can fully recover its state by replaying all events that belong to it. This is particularly useful if the actor is restarted or migrated in a cluster.

3. **Ensuring Exactly-Once Processing**  
   Transactionality and careful in-memory bookkeeping prevent the same event from being applied more than once. By committing events only after the entire command flow succeeds (and discarding them otherwise), the system guarantees that each event is processed exactly once.

---

## 3. Replication and Persistence Flow

1. **Replication Before Persistence**  
   Events generated by a successful transaction are first replicated to a secondary node (or cluster members). Only after confirming replication does the system commit these events to **RocksDB** (or an equivalent storage engine). This ensures that if the primary node fails, a secondary node can continue from the last replicated point without data loss.

2. **Storage in RocksDB**  
   Persisted events are stored in RocksDB so that actors can quickly load (or reload) their historical events for rapid recovery or horizontal scaling.

3. **Publication After Replication**  
   Once replication completes, events are published to external outputs (e.g., a message bus, read-model processors). This guarantees that the read side and any external subscribers see consistent, replicated dataâ€”no duplicate publications or partially committed states.

---

## 4. CQRS and Read-Side Consistency

1. **Decoupled Read and Write Models**  
   - **Command/Write Side**: Actors focus on domain logic, validate commands, and emit events.  
   - **Query/Read Side**: A separate model (or multiple projections) subscribes to the event stream to build query-optimized views.

2. **Eventual Consistency**  
   The read side is eventually consistent with the latest actor state. However, replication ensures that once events are published, they are safely mirrored across the cluster, preventing stale or divergent data in the read model.

3. **High-Performance Queries**  
   Since the read model is decoupled from command logic, it can be stored in specialized databases or caches to handle large query loads efficiently.

---

## 5. High Availability (HA)

1. **Primary-Secondary Setup**  
   By replicating events to a secondary node before committing them, the system maintains a hot standby. In case of a primary node failure, the secondary can become the new primary, having already received all events.

2. **No Duplication During Failover**  
   Because replication and event publication are carefully sequenced, a failover does not result in duplicate event processing. The newly active primary continues from the last acknowledged replication point.

3. **Actor Recovery**  
   Actors can be restarted or relocated to another node without losing state. Their events (already replicated) can be replayed to restore the exact in-memory state they had before.

---

## Summary

This actor-based system blends **CQRS** and **Event-Sourcing** with transactional guarantees and robust replication. By processing commands in a depth-first traversal across actors and persisting all-or-nothing event sets, it ensures exactly-once event application. Replication to secondary nodes occurs before persistence and publication, enabling high availability without risking duplicated or lost events. Finally, the CQRS pattern allows the read side to scale independently, offering efficient queries on a model that is always consistent with the replicated, event-sourced write side.
